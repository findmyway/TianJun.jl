<!DOCTYPE html>
<html lang="en-US"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>写给Python用户的Julia编程指南[updating] · Jun Tian</title><meta name="title" content="写给Python用户的Julia编程指南[updating] · Jun Tian"/><meta property="og:title" content="写给Python用户的Julia编程指南[updating] · Jun Tian"/><meta property="twitter:title" content="写给Python用户的Julia编程指南[updating] · Jun Tian"/><meta name="description" content="Documentation for Jun Tian."/><meta property="og:description" content="Documentation for Jun Tian."/><meta property="twitter:description" content="Documentation for Jun Tian."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-132847825-3"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-132847825-3', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../assets/custom.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.jpg" alt="Jun Tian logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Jun Tian</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">👋 About</a></li><li><span class="tocitem">💻 Programming</span><ul><li><a class="tocitem" href="../../programming/A_Deep_Dive_into_Distributed.jl/">A Deep Dive into Distributed.jl</a></li></ul></li><li><span class="tocitem">📖 Reading</span><ul><li><a class="tocitem" href="../../reading/Notes_on_Distributional_Reinforcement_Learning/">Notes on Distributional Reinforcement Learning</a></li></ul></li><li><a class="tocitem" href="../../AMA/">🙋 Ask Me Anything</a></li><li><a class="tocitem" href="../../blogroll/">🔗 Blogroll</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>写给Python用户的Julia编程指南[updating]</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>写给Python用户的Julia编程指南[updating]</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/findmyway/TianJun.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/findmyway/TianJun.jl/blob/master/docs/src/essays/From_Python_to_Julia/index.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><hr/><p>keywords: Julia,Python CJKmainfont: KaiTi –-</p><h1 id="写给Python用户的Julia编程指南[updating]"><a class="docs-heading-anchor" href="#写给Python用户的Julia编程指南[updating]">写给Python用户的Julia编程指南[updating]</a><a id="写给Python用户的Julia编程指南[updating]-1"></a><a class="docs-heading-anchor-permalink" href="#写给Python用户的Julia编程指南[updating]" title="Permalink"></a></h1><p>本文的目的是，为拥有Python编程经验的用户提供一些指引，方便其快速上手Julia。</p><h1 id="准备"><a class="docs-heading-anchor" href="#准备">准备</a><a id="准备-1"></a><a class="docs-heading-anchor-permalink" href="#准备" title="Permalink"></a></h1><h2 id="下载和安装"><a class="docs-heading-anchor" href="#下载和安装">下载和安装</a><a id="下载和安装-1"></a><a class="docs-heading-anchor-permalink" href="#下载和安装" title="Permalink"></a></h2><p><a href="https://julialang.org/downloads/">官网</a>提供了各个系统下的安装包，不过我建议新手先安装<a href="https://juliacomputing.com/products/juliapro.html">Julia PRO</a>，这个有点类似Python下的Anaconda，目前版本还没有1.0，这里以0.6.2为例，安装Julia的同时还会安装一些Julia下常见的包（省去了许多包管理麻烦，当然，也会带来一些新的小问题，这个碰到的时候再细说）。</p><p>由于我日常开发在Windows下，所以以下内容中操作系统相关的部分都以Windows为主（Linux和Mac下要容易很多，应该问题不大）。</p><p>安装后直接双击桌面的<span>$JuliaPro - Command Prompt 0.6.2.1$</span>快捷键即可打开Julia的REPL界面，就跟IPython有点像（后面会详细介绍其与IPython的联系和区别），建议将JuliaPRO安装路径下<span>$Julia-0.6.2$</span>中的bin目录添加到环境变量Path中，这样可以直接在git-bash或者cmd中直接运行julia(如下图)。</p><p><img src="Julia_REPL.png" alt="Julia_REPL"/></p><h3 id="Windows下开发学习的一点个人建议"><a class="docs-heading-anchor" href="#Windows下开发学习的一点个人建议">Windows下开发学习的一点个人建议</a><a id="Windows下开发学习的一点个人建议-1"></a><a class="docs-heading-anchor-permalink" href="#Windows下开发学习的一点个人建议" title="Permalink"></a></h3><p>我个人对Windows的态度是不吹不黑，但老实说，Windows下开发的体验很差。强烈建议安装个Debian/Ubuntu的WSL，除了不能直接跟底层GPU打交道外，我目前的开发中没遇到什么大问题，日常一般是开了两个terminal，一个显示REPL，另一个在Debian中切到对应的目录下做文件读取和服务管理。</p><h2 id="编辑器"><a class="docs-heading-anchor" href="#编辑器">编辑器</a><a id="编辑器-1"></a><a class="docs-heading-anchor-permalink" href="#编辑器" title="Permalink"></a></h2><p>一般Python的开发会选择PyCharm之类的IDE，不过Julia下还没有与PyCharm对应的IDE。安装JuliaPRO之后，桌面会有一个<span>$Juno for JuliaPro 0.6.2.1$</span>，其实就是一个Atom上套了个插件，如果你原来就用Atom的话，也许你会喜欢这个编辑环境。我个人在Windows下倾向使用VSCode+Julia插件，不过社区里也有人用Vim和Emacs，选择一个适合你的就好。</p><p>&lt;div class=&quot;alert alert-warning&quot;&gt; 使用VSCode的Julia插件的时候，需要配置(File -&gt; Preferences -&gt; Settings)julia的路径，如&quot;julia.executablePath&quot;: &quot;D:\workspace\software\JuliaPro-0.6.2.1\Julia-0.6.2\bin\julia.exe&quot;。 &lt;/div&gt;</p><p>当然，你一定注意到了桌面还有一个<span>$Jupyter 0.6.2.1$</span>，其实就是Jupyter+IJulia的内核，如果你习惯Jupyter的话几乎可以做到无缝迁移。</p><h2 id="REPL"><a class="docs-heading-anchor" href="#REPL">REPL</a><a id="REPL-1"></a><a class="docs-heading-anchor-permalink" href="#REPL" title="Permalink"></a></h2><p>在IPython中，最常用的一个功能是查看函数的帮助文档，通过在函数/方法名后面加一个<span>$?$</span>来实现，不过在Julia的REPL中，是先输入<span>$?$</span>再输入函数名：</p><p><img src="help_ENV.png" alt="使用？的例子"/></p><p>另外，在IPython中，经常会执行一些类似<span>$ls$</span>,<span>$pwd$</span>等等系统命令，这类命令在Julia中是通过函数来实现的(如<span>$readdir()$</span>, <span>$pwd()$</span>)。此外，原来<span>$%%$</span>的魔法函数也有对应的函数实现。不过如果是在REPL中，可以直接输入<code>;</code>进入shell模式，执行各种命令（自行对比iPython中加了<code>!</code>执行命令）。</p><h2 id="包管理"><a class="docs-heading-anchor" href="#包管理">包管理</a><a id="包管理-1"></a><a class="docs-heading-anchor-permalink" href="#包管理" title="Permalink"></a></h2><p>新版的Pkg管理模块比以前好用了很多，功能上有点像内置了一个<a href="https://github.com/pypa/pipenv">pipenv</a>。打开Julia的REPL后，按<code>]</code>进入Pkg管理模块，通过<code>generate Foo</code>即可新建一个Project，然后<code>add Bar</code>可以添加依赖，更多操作可以查看<a href="https://docs.julialang.org/en/latest/stdlib/Pkg/">Pkg</a>的Doc。</p><h1 id="语法细节"><a class="docs-heading-anchor" href="#语法细节">语法细节</a><a id="语法细节-1"></a><a class="docs-heading-anchor-permalink" href="#语法细节" title="Permalink"></a></h1><p>下面从一些日常的操作来介绍如何从Python迁移到Julia。</p><h2 id="代码结构"><a class="docs-heading-anchor" href="#代码结构">代码结构</a><a id="代码结构-1"></a><a class="docs-heading-anchor-permalink" href="#代码结构" title="Permalink"></a></h2><p>在Python中，代码是以目录结构组织起来的，然后用<span>$__init__.py$</span>来区分包和普通的目录，Julia的代码以模块（Modules）组织起来的，一个典型的Julia文件有如下结构：</p><pre><code class="language-julia hljs">module MyModule
using Lib

using BigLib: thing1, thing2

import Base.show

export MyType, foo

struct MyType
    x
end

bar(x) = 2x
foo(a::MyType) = bar(a.x) + 1

show(io::IO, a::MyType) = print(io, &quot;MyType $(a.x)&quot;)
end</code></pre><p>首先，<span>$module$</span>定义了整个模块，其作用范围一直到最后一行<span>$end$</span>，module名称一般采用驼峰式，在<span>$module$</span>中也可以定义一个<span>$__init__$</span>函数，其功能有点类似Python下的<span>$__init__.py$</span>文件（不完全对应，<span>$__init__.py$</span>某种程度上提供了下面<span>$export$</span>的功能）。</p><p><span>$using Lib$</span>有点类似Python中的<span>$from xxx import *$</span>，此刻你脑海中想到的第一个问题应该是命名冲突！对，我一开始也这么想的，后来习惯了发现，好像问题不大，因为Julia是带类型的，一定程度上通过重载缓解了这个问题。</p><p><span>$using BigLib: thing1, thing2$</span>就是显式地导入，类似<span>$from xxx import foo, bar$</span>。</p><p>个人感觉，Julia中<span>$import$</span>主要用于扩展某个函数的时候使用，这一点<span>$using$</span>做不到（<span>$using$</span>只用于提供查找变量的搜索空间）。~~<span>$importall$</span>就是<span>$import$</span>的扩展版~~(新版本中<span>$importall$</span>已废弃)。</p><p><span>$export$</span>则是，将该<span>$module$</span>内部的某些变量暴露出去。在Python中可能是通过<span>$__foo$</span>等来实现的。</p><p>函数部分的区别和联系后面再详述。</p><p>有时候，我们想直接从某个文件中导入，需要用<span>$include(&quot;foo.jl&quot;)$</span>来实现。</p><p>有一个函数<span>$whos()$</span>可以用来查看当前的变量信息，有点像Python中的<span>$globals()$</span>。</p><h2 id="数据结构"><a class="docs-heading-anchor" href="#数据结构">数据结构</a><a id="数据结构-1"></a><a class="docs-heading-anchor-permalink" href="#数据结构" title="Permalink"></a></h2><h3 id="index"><a class="docs-heading-anchor" href="#index">index</a><a id="index-1"></a><a class="docs-heading-anchor-permalink" href="#index" title="Permalink"></a></h3><p>&lt;div class=&quot;alert alert-danger&quot;&gt; 在Julia中，按index访问访问元素的时候，是从1而不是0开始的。这大概是我自己从Python迁移到Julia最不习惯的一方面（一不小心就出错了）。访问最后一个元素要使用<span>$end$</span>关键字，有点像Python中的<span>$-1$</span>。另外，Julia中索引的时候，是左闭右闭<span>$[]$</span>的，不是Python中的左闭右开<span>$[)$</span> &lt;/div&gt;</p><h3 id="string"><a class="docs-heading-anchor" href="#string">string</a><a id="string-1"></a><a class="docs-heading-anchor-permalink" href="#string" title="Permalink"></a></h3><ul><li>在Julia中，Char和String分别是用单引号<span>$&#39;$</span>和双引号<span>$&quot;$</span>初始化的，不能像Python中一样混用，三个双引号的用法是一致的。</li><li>字符串的连接采用<span>$*$</span>符号，而不是<span>$+$</span>。</li><li>字符串中支持变量替换，这个在Python3.6中有支持。二者只是表示上有所差别，Julia中是<span>$&quot;foo is ${1 + 1}&quot;$</span>，Python3.6中是<span>$f&quot;foo is {1 + 1}&quot;$</span>。</li><li>前面你可能注意到了，Python中可以在string前增加<span>$f&quot;&quot;$</span>，<span>$r&quot;&quot;$</span>等实现某种特殊功能，在Julia中，可以自定义许多非标准的字符串解释器，这个很强大，谁用谁知道。</li><li>读文件有一点稍稍不同，需要调用<span>$eachline$</span>函数，此外，Python中常常会用到的<span>$strip$</span>，Julia中对应的是<span>$chomp$</span>。</li></ul><h3 id="list"><a class="docs-heading-anchor" href="#list">list</a><a id="list-1"></a><a class="docs-heading-anchor-permalink" href="#list" title="Permalink"></a></h3><p>Python中最常用的就是list了，Julia中并没有严格与之对应的数据结构，不过，就一般使用而言，可以把一维的<span>$Array{Any,1}$</span>拿来用。</p><ul><li><span>$push!$</span>对应<span>$append$</span>，<span>$append!$</span>对应<span>$extend$</span>方法，这里提一下，Julia还是函数式的风格，而Python中平常使用还是面向对象的风格为主。此外还有<span>$prepend!$</span>等等对用的函数。</li><li>Python中的list comprehension 一样可以使用，<span>$[x * 2 for x in range(1,10) if x &gt; 3]$</span>。我个人为了保持代码风格的一致性，习惯用<span>$map$</span>，<span>$filter$</span>处理。</li><li>Python中<span>$list$</span>可以通过<span>$*$</span>来扩展，Julia中的Array并不能这样做（用<span>$repeat$</span>函数实现）。</li></ul><h3 id="Tuple"><a class="docs-heading-anchor" href="#Tuple">Tuple</a><a id="Tuple-1"></a><a class="docs-heading-anchor-permalink" href="#Tuple" title="Permalink"></a></h3><p>和Python中基本一致，~~未来也会~~目前支持类似Python3中的<code>NamedTuple</code>。</p><h3 id="numpy"><a class="docs-heading-anchor" href="#numpy">numpy</a><a id="numpy-1"></a><a class="docs-heading-anchor-permalink" href="#numpy" title="Permalink"></a></h3><p>这里单独说明下，Julia可以看作是自带了numpy的Python，Numpy的许多操作都能在<a href="https://docs.julialang.org/en/stable/stdlib/arrays/">标准库中Array</a>部分找到。</p><p>记录几个需要注意的点：</p><ul><li><span>$max$</span>和<span>$maximum$</span>的区别</li><li>初始化矩阵的时候，julia中用<span>$;$</span>来区分行</li><li>numpy中的数据类型一般通过<span>$dtype$</span>参数来指定（通过<span>$.astype$</span>做类型转换），而Julia中，则是采用带参数类型函数来初始化（如<span>$Array{T}(m,n)$</span>）</li><li>Julia中，array的存储顺序是按照列存储的，因此对矩阵赋值的时候需要注意区别。<span>$A[[1,2], [2,3]] = [2, 3,4 ,5]$</span>和<span>$[[1,2], [2,3]] = [2 3;4 5]$</span>的结果是有区别的。</li></ul><h3 id="iterator"><a class="docs-heading-anchor" href="#iterator">iterator</a><a id="iterator-1"></a><a class="docs-heading-anchor-permalink" href="#iterator" title="Permalink"></a></h3><ul><li>在python中经常会用到<span>$yield$</span>来生成迭代器，Julia中似乎没有找到对应的，我看到过一个相关的<a href="https://discourse.julialang.org/t/pygen-python-style-generators/3451/53">讨论</a>，一定程度上可以用Channel来实现。但仍然有些繁琐，希望以后能支持。</li><li>Python中有个itertools也经常用，这个在Julia中都是通过macro实现的，我个人感觉<a href="https://github.com/MikeInnes/Lazy.jl">Lazy.jl</a>基本够用，有些个性化需求的话，自己写一个也很方便。</li></ul><h3 id="struct"><a class="docs-heading-anchor" href="#struct">struct</a><a id="struct-1"></a><a class="docs-heading-anchor-permalink" href="#struct" title="Permalink"></a></h3><p>对比Python中的class</p><h3 id="macro"><a class="docs-heading-anchor" href="#macro">macro</a><a id="macro-1"></a><a class="docs-heading-anchor-permalink" href="#macro" title="Permalink"></a></h3><p>这个先放这里，在Python中很少会接触，前期迁移到Julia中的时候，只需要掌握一些常用的宏就可以了。</p><h2 id="Grammar"><a class="docs-heading-anchor" href="#Grammar">Grammar</a><a id="Grammar-1"></a><a class="docs-heading-anchor-permalink" href="#Grammar" title="Permalink"></a></h2><p>Julia中有些Python中没有的语法糖，个人感觉有些还算有意思，有些就比较累赘了。</p><ul><li><span>$do$</span>，这个没啥意思，就是把lambda搬了个位置</li><li>control flow上，因为没有了Python中的intent，需要用<span>$end$</span>来控制，虽然麻烦了点，但也可以理解。另外没有<span>$pass$</span>关键字。</li><li><span>$let$</span>用于局部的变量重绑定，特定时候可以解决命名冲突问题，其实有很多方式绕开。有点怀念Clojure中的<span>$let$</span></li></ul><h3 id="function"><a class="docs-heading-anchor" href="#function">function</a><a id="function-1"></a><a class="docs-heading-anchor-permalink" href="#function" title="Permalink"></a></h3><p>如果不考虑类型的话，Julia下的function和Python相比，主要的差别是：</p><ul><li><span>$end$</span>作为结尾，默认返回最后一个表达式，基本不需要<span>$return$</span>语句</li><li>positional，optional参数写法保持一致，keyword参数的写法用<span>$;$</span>做了分隔，不过一般都这么写：<pre><code class="language-julia hljs">function f(x; y=0, kwargs...)
  ###
end</code></pre></li><li>对于one-line definition，一般用<span>$f(x) = x$</span>的形式，如果一个表达式不够用，可以这样<span>$f(x) = (step1;step2;step3)$</span>。</li><li>lambda函数的写法看起来更简洁点，<span>$x -&gt; x^x$</span></li></ul><h3 id="operator"><a class="docs-heading-anchor" href="#operator">operator</a><a id="operator-1"></a><a class="docs-heading-anchor-permalink" href="#operator" title="Permalink"></a></h3><ul><li><span>$.$</span>，向量化操作，起初觉得没啥意思，记得Clojure有个macro实现类似的语义，后来发现，这个点真心简洁</li><li><span>$+=$</span>，注意Julia中默认是immutable的，所以类似<span>$A += 3$</span>的操作其实是做了个rebinding</li><li><span>$...$</span>,Python中会用<span>$*$</span>和<span>$**$</span>来对函数的参数解绑，在Julia是<span>$...$</span></li><li>注意区分<span>$==$</span>和<span>$===$</span>，类比Python中的<span>$==$</span>和<span>$is$</span></li></ul><h3 id="type"><a class="docs-heading-anchor" href="#type">type</a><a id="type-1"></a><a class="docs-heading-anchor-permalink" href="#type" title="Permalink"></a></h3><p>这个应该是从Python转Julia最大的区别，没有捷径，好好阅读文档。这里我记下点自己觉得比较常用的几个知识点：</p><ul><li><span>$typemax$</span>和<span>$typemin$</span>可以提供某些类型的取值范围(Int64,Float32等)</li></ul><h1 id="接下来？"><a class="docs-heading-anchor" href="#接下来？">接下来？</a><a id="接下来？-1"></a><a class="docs-heading-anchor-permalink" href="#接下来？" title="Permalink"></a></h1><ul><li>花点时间通读<a href="https://docs.julialang.org/en/stable/">Julia Documentation</a>。</li><li>看看<a href="https://en.wikibooks.org/wiki/Introducing_Julia">Introducing Julia</a>这个wikibook，日常使用中的问题都可以在这里找到答案。</li></ul></article><nav class="docs-footer"><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>. All contents published at this site follows <a href="https://creativecommons.org/licenses/by/4.0/">CC-BY-4.0</a> by default. For the Chinese version, please visit <a href="https://tianjun.me">tianjun.me</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Saturday 23 December 2023 15:51">Saturday 23 December 2023</span>. Using Julia version 1.9.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
